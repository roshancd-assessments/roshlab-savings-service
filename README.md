Savings Service API
===================

This is a stable, feature-complete microservice for a technical assessment. This README details the project's current architecture and capabilities, which have been built upon the foundation generated by Spring Initializr.

The project is built with Gradle and configured to use Java 21, containing the core API logic for a resilient and robust savings service.

‚öôÔ∏è Technologies Used
--------------------

-   **Spring Boot 3.5.4**: The primary framework for building the API.

-   **Java 21**: The JDK version used for the project.

-   **Gradle**: The build automation tool.

-   **Resilience4j**: For implementing resilience patterns like Circuit Breaker, Retry, and Time Limiter.

-   **Flyway**: Used for database schema migrations.

-   **Docker & Docker Compose**: For managing the development environment database.

-   **Testcontainers**: For providing a clean, ephemeral PostgreSQL database for integration tests.

-   **Caffeine**: An in-memory cache solution used for improved performance.

-   **Checkstyle**: For static code analysis to enforce coding standards.

üöÄ Getting Started
------------------

### Prerequisites

To build and run this project, you will need **JDK 21** installed on your system. You will also need **Docker** and **Docker Compose** for running the development database.

### Build

Use the Gradle Wrapper to build the project. This command will compile the code and run the default tests.

`./gradlew build`

### Dependencies

This project uses several key dependencies to function. Here's a brief overview:

-   **`spring-boot-starter-web`**: Provides the foundation for building web applications, including RESTful APIs, using Spring MVC.

-   **`spring-boot-starter-data-jpa`**: Enables the use of JPA (Java Persistence API) for database interactions.

-   **`spring-boot-starter-cache`**: Adds Spring's caching abstractions, allowing for easy integration with cache providers like Caffeine and other solutions like Redis.

-   **`spring-boot-starter-validation`**: Used for validating request data based on annotations (e.g., `@NotNull`, `@Size`).

-   **`postgresql`**: The JDBC driver for connecting to a PostgreSQL database.

-   **`resilience4j-spring-boot2`**: The library for implementing circuit breakers, retries, and time limiters.

-   **`spring-boot-starter-test`**: Provides essential testing utilities, including JUnit, Mockito, and Spring Boot's test framework.

-   **`flyway-core`**: Enables database migrations.

-   **`testcontainers-postgresql`**: Provides a lightweight, disposable PostgreSQL database for tests.

### How It Works

The Savings Service is a microservice designed to manage customer savings accounts.

-   **Core Logic**: The core business logic resides in the `SavingsAccountService`. It is designed to be highly resilient and non-blocking, using `CompletableFuture` for asynchronous operations.

-   **Resilience Patterns**: The service uses Resilience4j annotations (`@TimeLimiter`, `@Retry`, `@CircuitBreaker`) to protect against failures from external dependencies.

-   **Validation**: The `NickNameValidatorService` ensures that account nicknames do not contain offensive words.

-   **Data Access**: The `SavingsAccountRepository` handles all data interactions with the database, and `Flyway` manages database schema migrations.

-   **Transactions**: The `@Transactional` annotation is already applied to the service layer to ensure data consistency.

-   **Caching**: The `@Cacheable` annotation on the `getAccount` method caches account data using Caffeine to reduce database load. The architecture allows for easy swapping with a distributed cache like Redis for a production setup.

-   **API Documentation**: The API documentation is available via a static `openapi.yaml` file located under `src/main/resources/static`.

Running the Application
-----------------------

This project is configured to run in different Spring profiles, allowing for different configurations.

### **Development Profile**

By default, the `bootRun` task automatically activates the **dev** profile. It also manages the lifecycle of your PostgreSQL database container using `docker-compose.dev.yml`, providing a seamless local development experience.

1.  Start the application with the `dev` profile active: `./gradlew bootRun`

### **Test Profile**

Integration tests use the **test** profile and leverage Testcontainers to spin up a clean PostgreSQL instance for each test run. This provides a consistent and isolated testing environment.

-   `./gradlew test`

### **Local Docker Build**

To build and run the containerized application locally, you can use the provided `docker-compose.prod.yml` file. This is the recommended way to test the full application stack (including the database) locally. **Ensure you run this command from the project's root directory.**

1.  Start the application and its dependencies: `docker-compose -f docker-compose.prod.yml up --build`

2.  To stop the containers, press `Ctrl+C` and then run: `docker-compose -f docker-compose.prod.yml down`

**Swagger API Documentation**

Once the application is running, you can access the Swagger UI documentation at: `http://localhost:8080/swagger-ui/index.html`

üå≥ Git Branching Strategy
-------------------------

This project uses a simple and effective **Trunk-Based Development** strategy.

-   **`main` branch**: This is the single source of truth for all production-ready code. Commits to this branch must be clean, tested, and ready for deployment.

-   **Feature branches**: All new features and bug fixes are developed in short-lived feature branches, branched off of `main`. Once a feature is complete and its tests pass, it is merged back into `main` via a Pull Request.

This strategy ensures that the `main` branch is always stable. The CI pipeline is triggered on every commit to `main`, which should run the full suite of tests before deployment to a staging or production environment.

‚úÖ Enterprise-Ready Production Checklist
---------------------------------------

This checklist outlines the key steps to evolve this microservice into a production-ready, enterprise-grade solution.

### **1\. Core Microservice Enhancements**

-   [ ] **Externalize Configuration**: Move application properties to a centralized configuration server (e.g., Spring Cloud Config) for a multi-profile setup.

-   [x] **Robust Error Handling**: A global exception handler using `@ControllerAdvice` is already implemented to standardize API error responses.

-   [ ] **Security**: Add proper authentication and authorization (e.g., OAuth 2.0 with JWTs).

-   [ ] **Asynchronous Context Propagation**: Ensure security and tracing contexts are propagated across threads when using `CompletableFuture`.

-   [ ] **Improve Account Number Generation**: Replace the placeholder logic with a production-grade, globally unique identifier.

-   [ ] **Production Profile**: Create an `application-prod.yml` file to configure a live PostgreSQL database and other production-specific settings.

### **2\. Automation & CI Pipelines**

-   [x] **Version Control**: A Git repository on GitHub has been set up.

-   [x] **Containerization**: A `Dockerfile` has been added to package the application.

-   [x] **Static Code Analysis**: Checkstyle is currently used to enforce code quality and standards.

-   [x] **CI Pipeline Setup**: GitHub Actions are configured to automate the build and test stages. The pipeline also performs API contract validation using Postman with the `openapi.yaml` specification.

    -   [x] **Unit Test Stage**: Run unit tests automatically as a separate stage.

    -   [x] **Integration Test Stage**: Run repository-layer and component tests automatically.

    -   [x] **API Contract Validation**: Perform API contract testing using a tool like Postman against the `openapi.yaml` specification.

    -   [x] **Artifact Management**: The pipeline is now configured to build a Docker image.

    -   [ ] **Deployment Stage**: Automate deployment to a staging or production environment.

### **3\. Deployment & Operations**

-   [ ] **Orchestration**: Deploy the containerized application using a container orchestrator like **Kubernetes** for scaling, self-healing, and load balancing.

-   [ ] **Tracing and Monitoring**:

    -   [ ] **Distributed Tracing**: Implement tracing with tools like Zipkin or Sleuth to track requests.

    -   [ ] **Metrics**: Integrate with Prometheus to collect key metrics (latency, error rates).

    -   [ ] **Dashboards**: Use Grafana to visualize metrics and create monitoring dashboards.

-   [ ] **Logging**: Implement structured logging with a library like Logback and a centralized log management system (e.g., ELK stack, Splunk).

-   [ ] **Health Checks**: Configure Kubernetes to use liveness and readiness probes to ensure the application is healthy and ready to serve traffic.

üîó Key Links
------------

-   **API Documentation**: [openapi.yaml](https://github.com/roshancd-assessments/roshlab-savings-service/blob/main/src/main/resources/static/openapi.yaml "null")

-   **GitHub Repository**: [repository home](https://github.com/roshancd-assessments/roshlab-savings-service "null")

-   **GitHub Issues**: [issue tracker](https://github.com/roshancd-assessments/roshlab-savings-service/issues "null")

-   **GitHub Actions Pipeline**: [CI/CD pipeline](https://github.com/roshancd-assessments/roshlab-savings-service/actions "null")

-   **Built Container Image**: [Images]([https://github.com/roshancd-assessments/roshlab-savings-service/actions "null"](https://github.com/roshancd-assessments/roshlab-savings-service/pkgs/container/roshlab-savings-service))
